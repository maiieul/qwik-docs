---
title: Events
contributors:
  - mhevery
---
import CodeExample from '../../../../../components/code-example/index.tsx';
import UseTask from 'source:/src/routes/demo/tasks/use-task/index.tsx';
import Track from 'source:/src/routes/demo/tasks/track/index.tsx';
import TrackServerGuard from 'source:/src/routes/demo/tasks/track-server-guard/index.tsx';
import TrackFn from 'source:/src/routes/demo/tasks/track-fn/index.tsx';
import Cleanup from 'source:/src/routes/demo/tasks/cleanup/index.tsx';
import UseVisibleTask from 'source:/src/routes/demo/tasks/use-visible-task/index.tsx';
import UseVisibleTaskEager from 'source:/src/routes/demo/tasks/use-visible-task-eager/index.tsx';
import Resource from 'source:/src/routes/demo/tasks/resource/index.tsx';


# Tasks

Tasks are meant for running asynchronous operations as part of component initialization or change of component state. 

> **Note**: Tasks are similar to `useEffect()` in React, but there are enough differences that we did not want to call them the same so as not to bring preexisting expectations about how they work. The main differences are:
> - Tasks are asynchronous.
> - Task run on server and client.
> - Tasks run before rendering and can block rendering.


`useTask$()` should be your default go-to API for running asynchronous (or synchronous) work as part of component initialization or state change. It is only when you can't achieve what you need with `useTask$()` that you should consider using `useVisibleTask$()` or `useResource$()`.

The basic use case for `useTask$()` is to perform work on component initialization. `useTask$()` has these properties:
- It runs on the server and the client.
- It runs before rendering and blocks rendering.
- If multiple tasks are running then they are run sequentially in the order they were registered. An asynchronous task will block the next task from running until it completes.

Tasks can also be used to perform work when a component state changes. In this case, the task will rerun every time the tracked state changes. See: [`track()`](#track).

Sometimes a task needs to run only on the client and after rendering, in that case, you should use [`useVisibleTask$()`](#usevisibletask).

Sometimes a task should fetch data asynchronously and produce a signal (and not block rendering), in that case, you should use [`useResource$()`](#useresource).

## `useTask$()`

Let's look at the simplest use case of the task to run some asynchronous work on component initialization.

<CodeExample src={UseTask} sandboxStyle={{height: '6em'}}/>

> In this example 
> - The `useTask$()` computes the fibonacci number one entry per 100 ms. So 40 entries take 4 seconds to render. 
>   - The `useTask$()` executes on the server as part of the SSR (the result may be cached in CDN.)
>   - Because the `useTask$()` blocks rendering, the rendered HTML page takes 4 seconds to render.
> - Because this task has no `track()` it will never rerun, making it effectively an initialization code.
>   - Because this component only renders on the server, the `useTask$()` will never run on the client.

### `track()`

There are times when it is desirable to re-run a task when a component state changes. This is done by using the `track()` function. The `track()`. The `track()` function allows you to set up a dependency on a component state on the server and then re-execute the task when the state changes on the client.

> **Note**: If all you want to do is compute a new state from an existing state synchronously, you should use [`useComputed$()`](/docs/components/state/#usecomputed) instead.

<CodeExample src={Track} sandboxStyle={{height: '6em'}}/>

> On the server:
> - The `useTask$()` runs on the server and the `track()` function sets up a subscription on `text` signal.
> - The page is rendered.
> 
> On the client:
> - The `useTask$()` does not have to run (or be downloaded) eagerly because Qwik knows that the task is subscribed to the `text` signal from the server execution. 
> - When the user types in the input box, the `text` signal changes. Qwik knows that the `useTask$()` is subscribed to the `text` signal and it is at this time that the `useTask$()` closure is brought into the JavaScript VM to be executed. 
>
> The `useTask$()`
> - The `useTask$()` blocks rendering until it completes. If you don't want to block rendering (as in this case) make sure that the task is resolved, and run the delay work on a separate unconnected promise. (In our case we don't await `delay()`. Doing so would block rendering.)

### `track()` as a function

In the above example `track()` was used to track a specific signal. However, `track()` can also be used as a function to track multiple signals at once. 

<CodeExample src={TrackFn} sandboxStyle={{height: '6em'}}/>

> In this example the `track()` takes a function that not only reads the signal but also transforms its value to uppercase/lowercase. The `track()` is doing subscription on multiple signals and computes their value. 


### `cleanup()`

Sometimes when running a task cleanup work needs to be performed. When a new task is triggered, the previous task's `cleanup()` callback is invoked. (Also when the component is removed from the DOM then the `cleanup()` callback is also invoked.)

> - The `cleanup()` function is not invoked when the task is completed. It is only invoked when a new task is triggered or when the component is removed.
> - The `cleanup()` function is invoked on the server after the applications are serialized into HTML.
> - The `cleanup()` function is not transferable from server to client. (Cleanup is meant to release resources on the VM where it is running. It is not meant to be transferred to the client.)

This example shows how to implement a debounce feature using the `cleanup()` function.

<CodeExample src={Cleanup} sandboxStyle={{height: '6em'}}/>

## `useVisibleTask$()`

Sometimes a task needs to run only on the client and after rendering, in that case, you should use `useVisibleTask$()`. The `useVisibleTask$()` is similar to `useTask$()` but it only runs on the client and after initial rendering.

`useVisibleTask$()` has these properties:
- runs on the client only.
- eagerly executes code on the client when the component because visible.
- Runs after initial rendering.
- Does not block rendering.


> **Caution**: The `useVisibleTask$()` should be used as a last resort, because it eagerly executes code on the client. Qwik through [resumability]() goes out of its way to delay the execution of code on the client, and `useVisibleTask$()` is an escape hatch that should be used with caution. See [Best Practices](/best-practices/#dont-register-events-eagerly-with-usevisibletask) for more details.
> If you need to run a task on a client consider `useTask$()` with a server guard.
> <CodeExample src={TrackServerGuard} sandboxStyle={{height: '6em'}}/>
> In the above example the `useTask$()` is guarded by `isServer`. The `track()` is before the guard which allows the server to set up the subscription but does not execute any code on the server. The client then executes the `useTask$()` once the `text` signal changes.

This example shows how to use `useVisibleTask$()` to initialize a clock on the client only when the clock component becomes visible.

<CodeExample src={UseVisibleTask} sandboxStyle={{height: '6em'}}/>

> Notice how the clock's `useVisibleTask$()` does not run until the `<Clock>` component became visible.  The default behavior of `useVisibleTask$()` is to run the task when the component becomes visible. This behavior is implemented through [intersection observers](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

### Option `eagerness`

At times it is desirable to run `useVisibleTask$()` eagerly as soon as the application is loaded in the browser. In that case the `useVisibleTask$()` needs to run in eagre mode.  This is done by using the `{ strategy: 'document-ready' }`.

<CodeExample src={UseVisibleTaskEager} sandboxStyle={{height: '6em'}}/>

> In this example the clock starts running immediately on the client regardless of whether it is visible or not.

## `useResource$()`

`useResource$()` is half way between [`useTask$()`](#usetask) and [`useComputed$()`](/docs/components/state/#usecomputed).

`useResource$()` similarities and differences between `useTask$()` / `useComputed$()`:
- `useResource$()` does not block rendering unlike `useTask$()`
- It returns a value (Signal) just like `useComputed$()`, but it is asynchronous unlike `useComputed$()`.
- It is not a pure function like `useComputed$()`. It can have side effects. Specifically, it is intended that `useResource$()` will have side effects such as network requests.
- It uses [`track()`](#track)/[`cleanup()`](#cleanup) functions similar to `useTask$()`.

<CodeExample src={Resource} sandboxStyle={{height: '6em'}}/>

### `previous`

When `useResource$()` is re-executed, `previous` contains the previous value of the resource.